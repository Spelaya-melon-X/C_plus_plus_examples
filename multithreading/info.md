Данный материал для примеров будет взят преимущественно от сюда : [тык](https://rekovalev.site/multithreading-3-cpp/)

Для того , чтобы выводить атомарно - мы будем сначала собирать строчку используя `std::stringstream()` , а после используя `std::cout` выводить результат 

> example : 
```cpp
std::cout << (std::stringstream() << "Первая часть строки " << value << " Вторая часть строки\n").str();
```

### методы : 

#### потоки `std::thread`: 
- `.join()` - его вызов блокирует вызывающийся поток до тех пор , пока поток этого объекта не выполнит свою работу. 
  
- `std::thread::joinable()` в C++ — это метод, который возвращает `true`, если объект `std::thread` управляет активным потоком выполнения, и `false` в противном случае.
  
- `std::ref()` в C++ используется для *создания обёртки* вокруг ссылки на объект, которая будет передана в качестве аргумента в новый поток при его создании (Это необходимо тк `std::thread` по умолчанию создаёт копии аргументов, а `ref()` позволяет передавать ссылку, чтобы поток мог изменять исходный объект. ) 
  
- `std::cref()` — это вспомогательная функция в C++, которая создаёт объект [std::reference_wrapper](https://www.google.com/search?q=std%3A%3Areference_wrapper&sca_esv=a52577f178443ecc&biw=1060&bih=890&sxsrf=AE3TifMu3ieMNwlP-eXKqBFRrQih7MGSCw%3A1764091372550&ei=7OUlaayqIezvwPAPjZO0QA&ved=2ahUKEwiT8u3E6I2RAxUkOBAIHclGGj0QgK4QegQIARAB&uact=5&oq=std%3A%3Acref%28%29+c%2B%2B+%D1%87%D1%82%D0%BE+%D1%8D%D1%82%D0%BE&gs_lp=Egxnd3Mtd2l6LXNlcnAiHXN0ZDo6Y3JlZigpIGMrKyDRh9GC0L4g0Y3RgtC-SIMXUMQDWN0VcAJ4AZABAJgBfKABigWqAQM3LjK4AQPIAQD4AQGYAgOgAlrCAgoQABiwAxjWBBhHwgIIEAAYgAQYogTCAgUQABjvBcICCBAAGKIEGIkFmAMAiAYBkAYIkgcBM6AHsQayBwExuAdQwgcFMC4xLjLIBwo&sclient=gws-wiz-serp&mstk=AUtExfA_oAcz5nohg6Y0n_IRmLtDwtAbmPA03WiWV5ktJGzNi-fRrMbWAa-KCnt-_S-SCiDXNqO1Jfqsx1sHYXYWRh8ZT87q1ifjvCbJGzjPOhoRAeweacwNagRVXkOBhHkxvGQIM1d4-BttDPqecMxlNEYo_BdeE-aewHNc1Z5aQV9o6LFgI9qg5XNYh-JfdFd5HLWsXD_lO5Oq-O4EYjuHLp3FY3OgrH007b_31Mers0tyySl-knv9fNLNbstBddc22E-52egcvZ7fjRBm4pBvGm4uV4CXxbSEd35TZWjXjWILZw&csui=3) для `const` ссылки.
  
- `std::thread::detach()` - он позволяяет отсоединить поток от объекта `std::thread` , позволяя потоку продолжать выполнение независимо . После вызова этого метода объект `std::thread` может быть использован для другого потока выполнения.

- `.get_id()` - возвращает уникальный идентификатор потока.  (Этот идентификатор, представленный типом `std::thread::id`, позволяет отличать один поток от другого, что важно для управления и синхронизации потоков. ) 

- `hardware_concurrency` -  статический метод , который возвращает количество потоков выполнения, которые могут быть эффективно запущены параллельно.

- `std::promise` в C++ — это объект из стандартной библиотеки (`<future>`), который позволяет одному потоку (поставщику) предоставить значение или исключение для другого потока (потребителя) в будущем. (  Он служит механизмом связи между потоками, позволяя передавать данные асинхронно. Каждый объект `std::promise` связан с объектом `std::future`, который используется для получения результата.)

- `std::future` в C++ — это шаблонный класс из заголовочного файла `<future>`, представляющий результат асинхронной операции, который может быть получен в будущем.

- `set_value()` - метод , который используется для того , чтобы задать значение  ( для `std::promise`)

- `set_exception()` - метод , который можно установить , что в процессе произошло исключение  (`std::promise`)

 - `get_future()` - метод , для создания `std::future` из `std::promise` .  это метод класса `std::promise` который возвращает объект `std::future` . 

- `get()` - блокирует поток до тех пор, пока значение не будет установлено в связанном `std::promise` и возвращает его в точку вызова;

- `wait()` — блокирует вызывающий поток и ожидает, пока значение будет установлено, но не возвращает его в точку вызова;
  
  - `wait_for(const chrono::duration& relative_time)` — ожидает установки значения в течении указанного времени, по истечению возвращает:
    - `std::future_status::timeout` — время ожидания истекло,
    - `std::future_status::ready` — значение установлено до истечения времени ожидания;

- `wait_until(const chrono::time_point&amp; absolute_time)` — аналогично `wait_for`, но с абсолютной временной точкой.
  
- `future::valid()` - это функция-член класса `std::future`, которая проверяет, относится ли объект` std::future` к общему состоянию. : 
	- `true`, если объект `std::future `ссылается на общее состояние.
	- `false`, если объект `std::future` не ссылается на общее состояние.
  Объект `std::future` *ссылается на общее состояние*, если он был получен из функции поставщика, например:` std::promise::get_future()`, `std::packaged_task::get_future() и std::async().`

- `std::async` в C++ — это функция для запуска других функций *асинхронно*, то есть потенциально в *отдельном* *потоке*. Она возвращает объект `std::future`, который используется для получения результата выполнения функции после её завершения.
	- политика запуска — определяет как задача будет выполняться:
	    - `std::launch::async` — гарантирует, что задача будет выполнена асинхронно в отдельном потоке,
	    - `std::launch::deferred` — задача будет выполнена «лениво» (когда будет запрошен результат),
	    - не указание политики (использование значения по умолчанию) позволяет системе выбрать как выполнить задачу;
	- вызываемая функция;
	- передаваемые в функцию аргументы


----- 
- `std::mutex` — простейший мьютекс, который не рекомендуется для рекурсивного захвата одним и тем же потоком;
  
- `std::recursive_mutex` в C++ — это тип мьютекса, который позволяет одному и тому же потоку многократно блокировать его, не вызывая взаимоблокировки. Этот мьютекс подсчитывает количество вложенных блокировок, и для разблокировки требуется выполнить такое же количество вызовов `unlock`, прежде чем другие потоки смогут захватить его.
  
- `std::timed_mutex` и `std::recursive_timed_mutex` — позволяют пытаться захватить мьютекс в течение указанного времени.

- `std::lock_guard` — захватывает мьютекс при создании объекта и автоматически освобождает его при уничтожении объекта (не предоставляет явного способа освобождения мьютекса или повторного его захвата);

- `std::unique_lock` — позволяет не только автоматически захватывать и освобождать мьютекс, но и предоставляет возможность для ручного управления мьютексом (используется условными переменными);

- `std::shared_lock` (со стандарта C++14) — позволяет множеству потоков безопасно и одновременно читать данные, защищенные мьютексом, при этом гарантируя исключительный доступ для потока, выполняющего запись;

- `std::scoped_lock` (со стандарта C++17) — предназначен для замены `std::lock_guard` и `std::unique_lock` при необходимости одновременного захвата нескольких мьютексов — автоматически и безопасно управляет множеством мьютексов, предотвращая взаимные блокировки и упрощая синхронизацию в сложных многопоточных приложениях.

- `owns_lock` в C++ — это метод или свойство, которое проверяет, владеет ли поток, вызывающий этот метод, соответствующим объектом мьютекса. Это относится к классу `std::unique_lock ` который является оберткой вокруг мьютекса и имеет концепцию "владения".


- `std::try_to_lock` — это объект тега, используемый с `std::unique_lock` или `std::lock_guard` в C++ для указания того, что мьютекс следует попытаться захватить (разблокировать), но не блокировать процесс, если мьютекс уже занят. Если мьютекс доступен, он будет захвачен; если нет, операция немедленно завершится без блокировки.

- `std::defer_lock` — это пустой тег (struct) в C++, используемый с классами управления мьютексами, такими как `std::unique_lock`, чтобы указать, что конструктор не должен немедленно блокировать мьютекс.

- `is_lock_free()` в C++ — это метод класса `std::atomic`, который определяет, реализована ли атомарная операция с помощью "lock-free" (без блокировок) инструкций процессора или с помощью блокировки (например, мьютекса).
  
- `is_always_lock_free` — это член `std::atomic` в C++, который является константным булевым значением, указывающим, *гарантировано ли*, что атомарные операции над этим типом выполняются без использования блокировок (lock-free) на всех поддерживаемых платформах.  

----
- `std::atomic::store()` в C++ — это метод атомарного объекта, который *присваивает* ему новое значение, гарантируя, что операция записи будет *выполнена как единая*, неделимая операция

- `atomic::load` в C++ — это метод для атомарного *чтения значения* из объекта типа `std::atomic`, который гарантирует, что операция чтения будет *выполнена целиком*, без возможности прерывания другим потоком.

- `std::atomic::exchange` — это атомарная операция в C++, которая *одновременно заменяет* значение в атомарной переменной новым значением и *возвращает старое* значение, которое там хранилось до замены

- `std::atomic::compare_exchange_weak` в C++ — это *атомарная операция сравнения и обмена*, которая используется в многопоточном программировании для безопасного изменения переменной, если её текущее значение совпадает с ожидаемым.

- `std::atomic::compare_exchange_strong` в C++ — это метод для выполнения *атомарной операции сравнения и обмена*.
```cpp
	std::atomic<int> counter; 
	def {
		auto expected_value = counter.load() ; 
		auto desired = expected_value + 1
		while ( !counter.compare_exchange_strong( expected_value,desired ))

	}
```
вот   
	  1. **Сравнивает** `counter` с `expected_value`
	  2. **Если равны**: записывает `desired` в `counter` и возвращает `true`
	  3. **Если не равны**: записывает текущее значение `counter` в `expected_value` и возвращает `false`
цикл нужен , так как между операциями другой поток может изменить `counter` , 


- `std::atomic_compare_exchange` — это атомарная операция в C++, которая заменяет значение атомарной переменной на новое, если текущее значение соответствует ожидаемому.

- `std::atomic::fetch_add()/fetch_sub()` в C++ — это функция, которая атомарно (неделимо) добавляет/вычитает значение к атомарной переменной и возвращает *предыдущее* значение этой переменной до добавления.

- `notify_one` — уведомляет один поток об изменении значения;
- `notify_all` — уведомляет все потоки об изменении значения.
---
- `atomic_flag::test_and_set` в C++ — это атомарная операция, которая проверяет, установлен ли флаг, и *одновременно* устанавливает его

-  `atomic_flag::clear` — атомарно устанавливает флаг в состояние `false`;


- `std::binary_semaphore` — это примитив синхронизации из библиотеки C++20, представляющий собой семафор, который может находиться в двух состояниях: 0 или 1 . Он используется для *сигнализации* между потоками, например, для *управления доступом к общему ресурсу*, доступ к которому разрешен только *одному* потоку за раз, либо для ожидания завершения определенного действия в другом потоке.

- `acquire()` - атомарная опреация , которая уменьшает счетчик  ( для работы с `binary_semaphore` )
- `release()` - атомарная операция , которая увеличивает счетчик ( для работы с `binary_semaphore` )


- `std::counting_semaphore` — это примитив синхронизации в C++, который *управляет доступом к ресурсу*, позволяя одновременно *нескольким* потокам использовать его , в отличие от `std::mutex`, который пропускает только *один* поток за раз. Он использует внутренний счетчик для отслеживания количества доступных ресурсов: при попытке получения доступа (`acquire()`) счетчик уменьшается, а при освобождении (`release()`) увеличивается. Если счетчик равен нулю, операция `acquire()` блокируется до тех пор, пока не станет доступен новый ресурс.

- `try_acquire` — неблокирующая попытка захвата счетчика, возвращает `true` в случае успешного захвата.

--- 

- `std::barrier` в C++ — это объект из стандартной библиотеки C++20, который используется для *синхронизации* потоков в многопоточном программировании. Он *блокирует* потоки до тех пор, пока определённое количество потоков не достигнет барьера, после чего они могут продолжить выполнение одновременно.

- `arrive` — уменьшает счетчик, но не блокирует поток, возвращает токен, который передается в `wait`;

- `wait` — блокирует поток пока остальные не достигнут барьера, принимает токен из метода `arrive` через `std::move`;
  
- `arrive_and_wait` — уменьшает счетчик и блокирует поток пока остальные не достигнут барьера;
  
- `arrive_and_drop` — уменьшает счетчик и исключает поток из синхронизации (уменьшает общее количество ожидаемых потоков на барьере для следующих использований).
--- 
	
- `std::latch` — это механизм синхронизации в C++20 для многопоточной работы, представляющий собой *одноразовый* барьер, который блокирует потоки до тех пор, пока не будет *достигнут нулевой счётчик*. Это уменьшаемый счётчик, который инициализируется при создании, а потоки уменьшают его значение, чтобы дождаться завершения определённого количества операций или событий.

- `count_down` — уменьшает счетчик без блокировки потока;

- `try_wait` — проверяет достижение счетчиком нуля без блокировки;
  
- `wait` — блокирует поток, пока счетчик не достигнет нуля;
  
- `arrive_and_wait` — уменьшает счетчик и блокирует поток, пока счетчик не достигнет нуля.

### Замечания : 
- Лучше всего создавать потоки после завершения предыдущих ( чтобы не было гонки за поток вывода)
  
- Если не передавать *адрес* объекта, а сам *объект* класса при создании потока, то будет использована *копия* этого объекта.
  
- Компилятор не позволит передать объекты без `std::ref` и `std::cref`, если функция/метод ожидают ссылку или константную ссылку в качестве аргумента
  
- после вызова метода `get` объект `std::future` становится не связанным. Его связанность следует проверять методом `valid` перед вызовами `get`, `wait`, `wait_for`, `wait_until`.
  
- **Мьютексы** («mutual exclusion» — взаимное исключение) используются для обеспечения *взаимного исключения*, что позволяет *предотвратить* одновременный доступ к общим ресурсам в многопоточных приложениях. Они представляют собой блокировку, которая может находиться в одном из двух состояний: *заблокированном* и *разблокированном*.
  
- сравнение 2 способов избежать того , что при ложном пробуждении у нас все будет корректно работать : 
1: 
```cpp
while (!ready) {
    cv.wait(lck);
}
```
оно : 
	- **Проверка условия ДО и ПОСЛЕ** каждого ожидания
	- **Гарантирует**, что даже при ложном пробуждении условие будет перепроверено
	- **Более явный** и понятный код
2: 
```cpp
cv.wait(lock, [] { return ready; });
```


- опр **Семафор** — это *специальная переменная или объект*, используемый в программировании для *контроля доступа* к общим (разделяемым) ресурсам, таким как память, файлы или устройства.

- опр **Барьер** — это примитив синхронизации, который позволяет потоку или группе потоков ожидать оставшиеся потоки до перехода к следующей фазе выполнения.
  
  `std::barrier` - это механизм синхронизации, который блокирует выполнение группы потоков до тех пор, пока **все N потоков** не достигнут барьера.
  
  `std::barier` - это способ вызвать какую-то функцию , которая вызовется только тогда , когда n кол-во потоков прошли через барьер.